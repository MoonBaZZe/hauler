package network

import (
	"github.com/MoonBaZZe/hauler/common"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestMerkleTreeSelection(t *testing.T) {
	txs := make([]string, 0)
	for i := 97; i <= 122; i++ {
		txs = append(txs, string(rune(i)))
	}
	for i := 65; i <= 90; i++ {
		txs = append(txs, string(rune(i)))
	}

	lenTxs := len(txs)
	nextPoT := common.NextPowerOfTwo(lenTxs)
	arraySize := nextPoT*2 - 1
	merkleTree := make([]string, arraySize)
	copy(merkleTree, txs)

	// Start the array offset after the last transaction and adjusted to the
	// next power of two.
	offset := nextPoT
	for i := 0; i < arraySize-1; i += 2 {
		switch {
		// When there is no left child node, the parent is nil too.
		case len(merkleTree[i]) == 0:
			merkleTree[offset] = ""

		// When there is no right child, the parent is generated by
		// hashing the concatenation of the left child with itself.
		case len(merkleTree[i+1]) == 0:
			merkleTree[offset] = merkleTree[i] + merkleTree[i]

		// The normal case sets the parent node to the double sha256
		// of the concatenation of the left and right children.
		default:
			merkleTree[offset] = merkleTree[i] + merkleTree[i+1]
		}
		offset++
	}

	leaves := make([]string, 0)
	index := 0
	leaves = append(leaves, merkleTree[index])

	for index < arraySize-1 {
		if index%2 == 0 {
			leaves = append(leaves, merkleTree[index+1])
		} else {
			leaves = append(leaves, merkleTree[index-1])
		}
		index += nextPoT
		nextPoT /= 2
	}
	root := ""
	for _, h := range leaves {
		root += h
	}

	assert.Equal(t, root, merkleTree[arraySize-1], "equal roots")
}
